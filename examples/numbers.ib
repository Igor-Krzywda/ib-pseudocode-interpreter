// (a) (i) we would either get a segmentation fault (C/C++) or an error 'out of bounds'
// in higher level language (Java / Python etc.)
// (a)(ii) we need to find the size of an array (sizeof(arr) / sizeof(int) or we
// need to predefine the length of the array; if the compiler supports it, we could 
// use a function like arr.length() which returns the size of an array

method average_arr(ARR)
    LEN = ARR.length()
    SUM = 0
    loop COUNT from 0 to LEN - 1
        SUM = SUM + ARR[COUNT]
    end loop
    //return SUM / LEN
end method

ARR = [123,901.2,213,21]
output average_arr(ARR)

// (c)(i)  pre: ARR = [3.12, 43.2, 12.45, 78.43, 43.67]
//         post: ARR = [43.67, 43.2, 12.45, 78.43, 3.12]
// (c)(ii) when put in loop, reverses the array

method maxPos(ARR)
    LEN = ARR.length()
    MAX_INDEX = ARR[0]
    loop COUNT from 1 to LEN - 1
        if ARR[MAX_INDEX] < ARR[COUNT] then
            MAX_INDEX = COUNT
        end if
    end loop
    return MAX_INDEX
end method

method minPos(ARR)
    LEN = ARR.length()
    MIN_INDEX = 0
    loop COUNT from 1 to LEN - 1
        if ARR[MIN_INDEX] > ARR[COUNT] then
            MIN_INDEX = COUNT
        end if
    end loop
    return MIN_INDEX
end method
// no help from compiler: int max_pos = sizeof(ARR) / sizeof(int) - 1;
// note: connot be done on a pointer, only when the array is declared in the scope
